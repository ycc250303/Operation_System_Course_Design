RISC-V 汇编相关问题回答

1。哪些寄存器包含函数的参数？例如，在 main 函数调用 printf 时，哪个寄存器保存的是 13？

答：根据 RISC-V 的规定，a0-a7 用于保存函数的参数。在 call.asm 中，找到 printf 相关的汇编指令，可以看到 24: 4635 li a2,13 是在地址 24 的位置，将 13 加载到 a2，作为 printf 的第三个参数。因此，保存 13 的寄存器是 a2。

2.在 main 函数的汇编代码中，对函数 f 的调用在哪里？对函数 g 的调用又在哪里？（提示：编译器可能会内联函数。）

答：在 call.asm 中，26:45b1 li a1,12 是在地址 26 的位置，将 12 加载到 a1，作为 printf 的第二个参数，12 是 f(8)+1 的结果。说明编译器并没有调用函数 f，而是直接将返回值计算出来了，同样也没有对函数 g 的调用。

3.函数 printf 位于什么地址？

答：在 call.asm 中，每个函数开头都有一串十六进制的数字，如 000000000000000e <f>:、000000000000001c <main>:，该数字即为函数的地址。找到函数 printf 的地址为 0000000000000628。

4.在 main 中，紧接着 jalr 到 printf 之后，寄存器 ra 中的值是什么？

答：jalr rd, rs1, imm 的含义是：rd = PC + 4; PC = rs1 + imm，跳转到 PC。34: 5f8080e7 jalr 1528(ra) 是跳转到 ra + 1528 的地址，也就是 printf 的入口，在跳转前会把返回地址（即本条指令的下一条指令的地址）写入 ra，以便在执行 printf 后能返回到这里。因此，寄存器 ra 的值是 34 + 4 = 38。

5.运行相关代码。输出是什么？输出取决于 RISC-V 是否采用小端模式。如果 RISC-V 采用大端模式，你会将 i 设置为多少才能得到相同的输出？你需要改变 57616 为不同的值？

答：大端（big-endian）和小端（little-endian）指的是多字节数据类型中哪些字节最重要，并描述字节序列在计算机内存中的存储顺序。在大端系统中，序列中最高有效值存储在最低存储地址（即最前面）。在小端系统中，序列中最低有效值存储在最前面。例如，考虑将 1025（2 的 10 次方加 1）存储在一个 4 字节整数中：00000000 00000000 00000100 00000001。其大端和小端的存储方式不同。许多大型计算机采用大端架构，而大多数现代计算机采用小端架构。相关代码的输出结果可以判断运行程序的计算机采用小端模式，如果采用大端模式，需要将 i 改为 0x726c6400，将 57616（十六进制为 e110）改为 286（十六进制为 011e）。

6.在相关代码中，'y=' 后面的值是多少？为什么会这样？

从汇编和底层实现的角度来看，在 RISC-V 架构下，调用 printf 时，前几个参数会被依次放入 a0、a1、a2、a3 等寄存器。例如，printf("x=%dy=%d", 3); 实际上传递了两个参数：a0 存放格式字符串 "x=%dy=%d"，a1 存放整数 3，但没有为第二个 %d 提供参数（a2 未被初始化）。当 printf 在处理格式字符串时，遇到第一个 %d，它会从 a1 取出 3 输出；遇到第二个 %d，它会从 a2 取值，但 a2 里此时可能是上一次函数调用遗留的内容，或者是任意的内存数据，因此输出的 y= 后面会显示一个不可预测的值。这正是因为参数数量和格式化占位符数量不匹配导致的汇编级“脏数据”泄漏到输出中。